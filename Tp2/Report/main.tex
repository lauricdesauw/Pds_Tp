\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{minted}

\newcommand{\code}[1]{\mintinline{OCaml}|#1|}

\title{A front compiler for VSL+}
\author{Yan Garito, Lauric Desauw}
\date{December 2019}

\begin{document}

\maketitle

\section{Introduction}
\section{General structure}

A program is seen as a block enriched with a couple of 'instructions', which are either prototypes for functions or functions themselves.

\section{Expressions}

Expressions have been implemented in a straightforward way: they are represented as trees where inner nodes are operations and leaves are either integers or \code{variables} (a variable, an element from an array or a function call). \\
The hard parts about expressions were:
\begin{itemize}

\item operation priority: $2+3 \times 3$ yields $11$ because $\times$ has priority over $+$. This was handled through the \code{factor} parsing function. Indeed, if this parsing function sees a multiplication or a division, it keeps constructing the expression tree, which results in the correct operation priority.
\item parentheses: parentheses were handled through both the \code{factor} and the \code{primary} parsing functions, which look out for a \code{'LP; expression; 'RP} pattern. 
  
\end{itemize}
  
\section{Blocks}

Blocks are seen as two lists: a list of instructions, which must be declarations and a list of \code{codeObj} which can be instructions (other than declarations), control structures such as loops or blocks. \\
The toughest part about our block implementation is the symbol table handling \TODO

\section{Control structure}

Those were implemented in a straightforward way. There were no particular difficulties in implementing those.

\section{Arrays}

\TODO

\section{Functions}

\TODO

\section{PRINT and READ}

\begin{itemize}
\item[\underline{Print}:] We have defined an instruction \emph{PrintInstruction}
  which takes a list of \emph{printable} elements, which can either be strings or integer expressions. \\
  The string to be printed is generated by replacing all of the integer expressions by the
  string \emph{``\%d''}, remembering which expression it is associated with and merging all the resulting strings. \\
  This string is put in the header as a global variable. \\
  The function \emph{@printf} is then called with the previous string and the variables we want to print. 
\item[\underline{Read}:] The method is the same as previously but instead of
  \emph{printable} the instruction uses \emph{variables} and we call the llvm \emph{@scanf} function
\end{itemize}

\section{Pointers and Structures}
As an extension we chose to implement pointers and structures in our language. First, the pointers are useful
when we want a function to 'return' multiple values, as we can put all of them in pointers passed as arguments and retrieve the values stored therein.\\
Then, structures allow programmers to give meaning to groups of variables and to reduce the number of arguments of functions, thus making function calls more readable. 

\subsection{Implementation of Pointers}
\subsection{Implementation of Structures}




\end{document}