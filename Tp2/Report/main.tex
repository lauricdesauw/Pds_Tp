\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{minted}

\newcommand{\code}[1]{\mintinline{OCaml}|#1|}

\title{A front compiler for VSL+}
\author{Yan Garito, Lauric Desauw}
\date{December 2019}

\begin{document}

\maketitle


\section{General structure}

A program is seen as a block enriched with a couple of 'instructions', which are either prototypes for functions or functions themselves.


\section{Expressions}

Expressions have been implemented in a straightforward way: they are represented as trees where inner nodes are operations and leaves are either integers or \code{variables} (a variable, an element from an array or a function call). \\
The hard parts about expressions were:
\begin{itemize}

\item operation priority: $2+3 \times 3$ yields $11$ because $\times$ has priority over $+$. This was handled through the \code{factor} parsing function. Indeed, if this parsing function sees a multiplication or a division, it keeps constructing the expression tree, which results in the correct operation priority.
\item parentheses: parentheses were handled through both the \code{factor} and the \code{primary} parsing functions, which look out for a \code{'LP; expression; 'RP} pattern. 
  
\end{itemize}
  
\section{Blocks}

Blocks are seen as two lists: a list of instructions, which must be declarations and a list of \code{codeObj} which can be instructions (other than declarations), control structures such as loops or blocks. \\
The toughest part about our block implementation is the symbol table handling. We had to tweak our functions a bit such as \code{ir_of_instruction} to make them return the symbol table. This way, when we have a \code{DefineInstruction}, the new symbol can be added to it. \\
Because the whole program is treated as a block, if a function is declared, it can be used everywhere after that.  \\
The main problem we add with blocks is the ability to define a variable named \code{a} if it haven't be already done in this block. With our first code this was impossible if another varaible \code{a} was defined in another block. So we have add \code{id} to the variables names, which were stocked in the symbol table, like thaht we could look in the symbol table the last appearence of our variable and use the id for the current block. 

\section{Control structure}

Those were implemented in a straightforward way. There were no particular difficulties in implementing those. Note that we used the blocks to represent each part of the structure. For example with the if there is one block for the then part and one for the else part. 

\section{Arrays}

Arrays are simply the arrays of llvm. We had some difficulties to have access to the type of the array, which contains its size. So we changed the types in order to store the size of the array inside its type. This way, when we wish to get an element from an array, the symbol table can be checked to see whether the element that is accessed exists. 

\section{Functions}

Functions hold a particular role in our code. First, their type contains their name but also their return type and the list of their parameters. Since parameters can only be integers, their types are not specified. We had some trouble with functions at the end because our way of treating blocks made it so the symbol table could not be changes in the second part, but the whole program is contained in a block's second part. Therefore we distinguished the global block, which contains the program from the other blocks. By doing so, we allow \code{ProtoInstruction} and function definitions to add functions to the symbol table. 

\section{PRINT and READ}

\begin{itemize}
\item[\underline{Print}:] We have defined an instruction \code{PrintInstruction}
  which takes a list of \code{printable} elements, which can either be strings or integer expressions. \\
  The string to be printed is generated by replacing all of the integer expressions by the
  string \code{``\%d''}, remembering which expression it is associated with and merging all the resulting strings. \\
  This string is put in the header as a global variable. \\
  The function \emph{@printf} is then called with the previous string and the variables we want to print. 
\item[\underline{Read}:] The method is the same as previously but instead of
  \code{printable} the instruction uses \code{variables} and we call the llvm \emph{@scanf} function
\end{itemize}

\section{Pointers and Structures}
As an extension we chose to implement pointers and structures in our language. First, the pointers are useful
if we want a function to 'return' multiple values, as we can put all of them in pointers passed as paramaeters and retrieve the values stored therein.\\
Then, structures allow programmers to give meaning to groups of variables and to reduce the number of arguments of functions, thus making function calls more readable. 

\subsection{Implementation of Structures}

Structures are defined much like in C: the keyword struct, followed by the name of the structure and a list of declarations in-between curly braces to define the various fields of the structure.

Declaring a variable using a structure as its type follows the same rules as declaring an integer variable: only the INT keyword is replaced with the name of the structure.
In LLVM we used array of pointer to represent our structure and we stocked the equivalent indice/field in the table of symbols. 

Unfortunately, our implementation of structures is far from complete. Indeed, we handle fields poorly. Instead of handling them in the symbol table, which seems natural now, we tried to handle them outside of it which complicated a lot of things for us. Our implementation make allow us to handle easily the struct in the expressions but the declaration is a tougher part, with the implementation described previously it may have been easier. Ultimately, we abandoned trying to fix our implementation of structures because of bugs in the mandatory work we had not noticed prior to that.


\end{document}